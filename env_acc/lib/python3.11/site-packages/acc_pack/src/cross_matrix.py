# --- ---*- coding: utf-8 -*-

import numpy as np
import pandas as pd

# ---

wersja = "w1.2021.07.27"
opis = """
Moduł dostarcza klas do: {0}.

- obliczania 'cross matrix' z danych zawierających etykiety prawdziwe i
  predicted.
- jeśli dostępne są nazwy słowne klas stosuje je

""".format(
    wersja
)


# ---

class ConfusionMatrix:
    """Zwraca dwa rodzaje cross matrix:
    1. 'cros'       - standard, bez podsumowanych wierszy i kolumn, bez
                        opisów słownych
    2. 'cros1'      - z podsumowanymi wierszami i kolumnami. Jeśli są
                        dostępne dodaje opisy słowne (etykiety)

    """

    def __init__(self, data=None, etykieta="klas"):
        self.etykieta = etykieta

        if data is not None:
            self.__call__(data)

    def __call__(self, data):

        self.labels, self.true_values, self.predicted = self._get_data(data)

        # --- utwórz słownik mapujący true_values na labels
        if self.labels is None:
            self.map_labels = self._make_labels_and_map(
                self.true_values, self.etykieta
            )
        else:
            self.map_labels = self._dict_of_labels(
                self.labels, self.true_values
            )

        # --- utwórz cross tab w podstawowej wersji
        self.cros_raw = self._cross_tab(self.true_values, self.predicted)

        # --- wyrównaj liczbę wierszy i kolumn
        self.cros_raw = self._wyrownaj_cros(self.cros_raw)

        # --- zamień liczby na nazwy
        self.cros_raw = self._etykiety_liczbowe_na_stringi(self.cros_raw)

        # --- wstaw opisy słowne do cross
        self.cros = self._etykiety_opisowe(self.cros_raw, self.map_labels)

        # --- dodaj sumy wierszy i kolumn do cross
        self.cros_full = self._podsumowanie(self.cros)

    # --- ---

    def _get_data(self, data):
        """Odczytuje dane.
        Args:
            - data: lista list, pd.DataFrame, np.array. Dane to 2 lub 3
              kolumny:
              -- 2 kolumny: true_values, predicted
              -- 3 kolumny: labels, true_values, predicted
        """
        if isinstance(data, list) or isinstance(data, tuple):
            data = np.array(data).T
        else:
            data = np.array(data)

        if data.shape[1] == 2:
            labels = None
        elif data.shape[1] == 3:
            labels = data[:, 0]
        true_values = data[:, -2].astype("int")
        predicted = data[:, -1].astype("int")

        return labels, true_values, predicted

    # --- ---

    def _make_labels_and_map(self, true_values, etykieta="klasa"):
        """Jeśli dane nie zawierają etykiet słownych klas, metoda tworzy
        etykiety i mapę etykiet (słownik).
        Args:
            - true_values:  lista, np.array, df.series
            - etykieta:     str, domyślna nazwa wspólna dla klas
        """
        uniq = [str(val) for val in set(true_values)]
        if len(uniq) > 10:
            n = 2
        else:
            n = 1
        labels = [f"{etykieta}_{i:0{n}}" for i in uniq]
        return dict(zip(uniq, labels))

    # --- ---

    def _dict_of_labels(self, labels, true_values):
        """Tworzy mapę klas jeśli dane zawierają w sobie etykiety słowne klas.
        """
        true_values = [str(val) for val in true_values]
        sl = dict(set(zip(true_values, labels)))
        return sl

    # --- ---

    def _cross_tab(self, true_values, predicted):
        cros = pd.crosstab(
            true_values,
            predicted,
            rownames=["true_values"],
            colnames=["predicted"],
        )
        return cros

    # --- ---

    def _wyrownaj_cros(self, cros):
        """Jeśli wyniki klasyfikacji nie zawierają wszystkich prawdziwych klas
        (jakiejś klasy nie wykryto), to cross matrix ma mniej kolumn
        (klasyfikacja) niż wierszy prawdy. Trzeba dodać kolumny z brakującymi
        klasami z zerowymi wystąpieniami. .
        """
        cros = cros.copy()
        s1 = set(cros.index.values)  # --- wartości prawdziwe - true
        s2 = set(cros.columns.values)  # --- kolumny cross

        # --- uzupełnia kolumny
        if len(s1.difference(s2)) > 0:
            dif = s1.difference(s2)
            for n in dif:
                cros.loc[:, n] = [0 for i in range(cros.shape[0])]

        cros = cros.astype("int")
        cros.sort_index(axis=0, inplace=True)
        cros.sort_index(axis=1, inplace=True)
        return cros

    # --- ---

    def _etykiety_liczbowe_na_stringi(self, cros):
        "Gdy etykiety kolumn i wierszy są liczbami - zamienia je na stringi."
        cros = cros.copy()
        kol_name = cros.columns.name
        row_name = cros.index.name

        kols = [str(x) for x in cros.columns]
        rows = [str(x) for x in cros.index]

        cros.columns = kols
        cros.columns.name = kol_name

        cros.index = rows
        cros.index.name = row_name
        return cros.astype("int")

    # --- ---

    def _podsumowanie(self, cros):
        cros = cros.copy()
        sum_row = cros.sum(axis=1).to_numpy()
        cros.loc[:, "sum_row"] = sum_row

        sum_col = cros.sum(axis=0).to_numpy()
        cros.loc["sum_col", :] = sum_col

        return cros.astype("int")

    # --- ---

    def _etykiety_opisowe(self, cros, map_labels):
        """Tworzy nową cross matrix w której zmienia nazwy kolumn i wierszy
        z liczb na opisy słowne np. na owiec, zyto itp.
        """
        # if self.labels is not None:
        cros = cros.copy()

        # --- pobierz aktualne liczbowe nazwy kolumn i wierszy
        all_names = cros.columns.to_list()

        if "sum_row" in all_names:
            old = all_names[:-1]
        else:
            old = all_names[:]
        # --- konwersja na string
        old = [str(x) for x in old]

        kols = [map_labels.get(key) for key in old]
        rows = kols[:]

        if len(rows) < len(all_names):
            kols.append("sum_row")
            rows.append("sum_col")

        cros.columns = kols
        cros.index = rows
        cros.axes[1].name = "predicted"
        cros.axes[0].name = "true"

        return cros.astype("int")


# --- ---
