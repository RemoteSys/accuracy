# -*- Encoding: utf-8 -*-

"""2023-07-27:
    - rozpoczęcie modernizacji kodu
    - na razie działa po staremu
    - nowa klasa: FormatList
  Nowa koncepcja:
    - klasy nie drukują tylko zwracają text
    - dzięki temu będą testy jednostkowe
    - print wykona klasa ostateczna.
"""
# --

from tabulate import tabulate
# --

class PrintDict(object):
    '''Klasa dostarcza metody wuświetlania danych ze słownika'''

    def _calc_max_lenght(self, values):
        '''Oblicza długość maksymalną wartości w słowniku, żeby odpowiednia
        można sformatować odległości w printowanym napisie.

        Args:
            values: slownik.values() lub slownik.keys()
        '''
        values_list = list(values)

        # konwertuje wartości na stringi by móz użyć len()
        values_list = list(map(str, values_list))
        max_lenght = max(map(len, values_list))
        return max_lenght
    # --

    def print_dict(self, slownik, offset=4):
        v = self._calc_max_lenght(slownik.values())
        k = self._calc_max_lenght(slownik.keys())
        s1 = '{:>2}{:<'
        s2 = k + offset
        s3 = '}{!r:<}'
        napis = '{}{}{}'.format(s1, s2, s3)
        print('\n')
        n = int(v/2 + k)
        if n > 120:
            n = 65
        print(n * '--')
        for kl in slownik.keys():
            print(napis.format('', kl, slownik[kl]))
        print(n*'--', '\n')
# --


class FormatList(object):
    '''Klasa dostarcza metodę, która z listy tworzy string do printowania.'''

    def _get_max_item_len(self, lista: list) -> int:
        """Oblicza długość najdłuższej podlisty z listy."""
        k = [len(str(x)) for x in lista]
        n = max(k)
        return n
    # --

    def print_list(self, lista, offset=4, nr=False):
        n = self._get_max_item_len(lista)
        if nr:
            s1 = '{:>1}{:>3}.{:<2}{!r:<'
            s2 = int(n+offset/2)
            s3 = '}'
            n += 6
        else:
            s1 = '{:>2}{:<'
            s2 = n + offset
            s3 = '}'
        napis = '{}{}{}'.format(s1, s2, s3)
        if n > 120:
            n = 65
        i = 0  # jeśli chcemy numerować wiesze to użyjemy i
        # print(n*'-')
        text = []
        for item in lista:
            i += 1
            if nr:
                text.append(napis.format('', i, '', str(item)))
            else:
                text.append(napis.format('', str(item)))
        # print(n*'-', '\n')
        # print('\n')
        text = '\n'.join(text)
        return text
# --

class PrintList(object):
    '''Klasa dostarcza metody wyświetlania danych ze słownika'''

    def print_list(self, lista, offset=4, nr=False):
        k = [len(x) for x in lista]
        n = max(k)
        if nr:
            s1 = '{:>1}{:>3}.{:<2}{!r:<'
            s2 = int(n+offset/2)
            s3 = '}'
            n += 6
        else:
            s1 = '{:>2}{:<'
            s2 = n + offset
            s3 = '}'
        napis = '{}{}{}'.format(s1, s2, s3)
        if n > 120:
            n = 65
        i = 0  # jeśli chcemy numerować wiesze to użyjemy i
        # print(n*'-')
        for item in lista:
            i += 1
            if nr:
                print(napis.format('', i, '', str(item)))
            else:
                print(napis.format('', str(item)))
        # print(n*'-', '\n')
        print('\n')
# --


class PrintPk1(PrintDict, PrintList):
    def __init__(self, data, dekoruj=True):
        self.data = data
        if isinstance(self.data, list):
            self.print_list(self.data)
        elif isinstance(self.data, dict):
            self.print_dict(self.data)


class PrintPk(PrintDict, PrintList):
    def __init__(self, data, args=False):
        self.data = data
        if args:
            fmt = 'simple'
        else:
            fmt = 'plain'

        if isinstance(self.data, list):
            print(tabulate(data, tablefmt=fmt))
        elif isinstance(self.data, dict):
            print(tabulate(data.items(), tablefmt=fmt))
# --


if __name__ == '__main__':
    pass
